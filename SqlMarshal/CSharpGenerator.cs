// -----------------------------------------------------------------------
// <copyright file="CSharpGenerator.cs" company="Andrii Kurdiumov">
// Copyright (c) Andrii Kurdiumov. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace SqlMarshal;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// Stored procedures generator for C#.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class CSharpGenerator : AbstractGenerator
{
    private const string CSharpAttributeSource = @"// <auto-generated>
// Code generated by SqlMarshal Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable

namespace SqlMarshal.Annotations
{
    [System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]
    internal sealed class SqlMarshalAttribute: System.Attribute
    {
        public SqlMarshalAttribute()
            => (StoredProcedureName) = (string.Empty);

        public SqlMarshalAttribute(string name)
            => (StoredProcedureName) = (name);

        public string StoredProcedureName { get; }
    }

    [System.AttributeUsage(System.AttributeTargets.Parameter, AllowMultiple=false)]
    internal sealed class RawSqlAttribute: System.Attribute
    {
        public RawSqlAttribute() {}
    }

    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple=false)]
    internal sealed class RepositoryAttribute: System.Attribute
    {
        public RepositoryAttribute(global::System.Type entityType)
        {
            EntityType = entityType;
        }

        public global::System.Type EntityType { get; }
    }
}
";

    /// <inheritdoc/>
    public override void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization((pi) =>
        {
            pi.AddSource("SqlMarshalAttribute.cs", CSharpAttributeSource);
        });
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <inheritdoc/>
    protected override SyntaxNode GetParameters(IMethodSymbol methodSymbol)
    {
        var parametersNodes = methodSymbol.Parameters.Select((parameterSymbol, index) => GetParameterDeclaration(methodSymbol, parameterSymbol, index));
        var separatedList = methodSymbol.Parameters.Length == 0
            ? SeparatedList<ParameterSyntax>()
            : SeparatedList(parametersNodes, methodSymbol.Parameters.Take(methodSymbol.Parameters.Length - 1).Select(_ => Token(SyntaxKind.CommaToken).WithTrailingTrivia(Whitespace(" "))));
        return ParameterList(separatedList);
    }

    private static ParameterSyntax GetParameterDeclaration(IMethodSymbol methodSymbol, IParameterSymbol parameter, int index)
    {
        var typeAsClause = ParseTypeName(parameter.Type.ToDisplayString()).WithTrailingTrivia(Whitespace(" "));
        if (parameter.RefKind == RefKind.Out)
        {
            var parameterSyntax = Parameter(default, SyntaxTokenList.Create(Token(SyntaxKind.OutKeyword).WithTrailingTrivia(Whitespace(" "))), typeAsClause, Identifier(parameter.Name), @default: null);
            return parameterSyntax;
        }
        else if (parameter.RefKind == RefKind.Ref)
        {
            var parameterSyntax = Parameter(default, SyntaxTokenList.Create(Token(SyntaxKind.RefKeyword).WithTrailingTrivia(Whitespace(" "))), typeAsClause, Identifier(parameter.Name), @default: null);
            return parameterSyntax;
        }
        else if (methodSymbol.IsExtensionMethod && index == 0)
        {
            var parameterSyntax = Parameter(default, SyntaxTokenList.Create(Token(SyntaxKind.ThisKeyword).WithTrailingTrivia(Whitespace(" "))), typeAsClause, Identifier(parameter.Name), @default: null);
            return parameterSyntax;
        }
        else
        {
            var parameterSyntax = Parameter(default, default, typeAsClause, Identifier(parameter.Name), @default: null);
            return parameterSyntax;
        }
    }

    internal class SyntaxReceiver : ISqlMarshalSyntaxReceiver
    {
        public List<IMethodSymbol> Methods { get; } = new List<IMethodSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is MethodDeclarationSyntax methodDeclarationSyntax)
            {
                // Get the symbol being declared by the field, and keep it if its annotated
                IMethodSymbol? methodSymbol = context.SemanticModel.GetDeclaredSymbol(context.Node) as IMethodSymbol;
                if (methodSymbol == null)
                {
                    return;
                }

                if (methodSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "SqlMarshal.Annotations.SqlMarshalAttribute"))
                {
                    this.Methods.Add(methodSymbol);
                }

                if (methodSymbol.ContainingType.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "SqlMarshal.Annotations.RepositoryAttribute"))
                {
                    this.Methods.Add(methodSymbol);
                }
            }
        }
    }
}
